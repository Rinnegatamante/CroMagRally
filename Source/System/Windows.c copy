/****************************/
/*        WINDOWS           */
/* (c)2000 Pangea Software  */
/* By Brian Greenstone      */
/****************************/


/***************/
/* EXTERNALS   */
/***************/

#include 	<Folders.h>
#include 	<DrawSprocket.h>
#include 	<stdlib.h>
#include 	<CodeFragments.h>
#include	"globals.h"
#include	"windows.h"
#include	"misc.h"
#include "objects.h"
#include "file.h"
#include "input.h"
#include <TextUtils.h>


extern	NewObjectDefinitionType	gNewObjectDefinition;
extern	ObjNode	*gCurrentNode,*gFirstNodePtr;
extern	float	gFramesPerSecondFrac,gAdditionalClipping;
extern	short	gPrefsFolderVRefNum;
extern	long	gPrefsFolderDirID;
extern	Boolean				gOSX;
extern	PrefsType			gGamePrefs;
extern	Boolean			gSongPlayingFlag;
extern	Movie				gSongMovie;
extern	WindowPtr			g1PixelWindow;

/****************************/
/*    PROTOTYPES            */
/****************************/

static void PrepDrawSprockets(void);
static void MoveFadeEvent(ObjNode *theNode);
static Boolean SetupEventProc(EventRecord *event);
static pascal Boolean VideoModeTimeOut (DialogPtr dp,EventRecord *event, short *item);
static void DoVideoConfirmDialog(void);


/****************************/
/*    CONSTANTS             */
/****************************/


#define	ALLOW_FADE		1

#if 0
#define MONITORS_TO_FADE	gDisplayContext
#else
#define MONITORS_TO_FADE	nil
#endif

/**********************/
/*     VARIABLES      */
/**********************/

long					gScreenXOffset,gScreenYOffset;
WindowPtr				gCoverWindow = nil;
DSpContextReference 	gDisplayContext = nil;
Boolean					gLoadedDrawSprocket = false;

static unsigned long	gVideoModeTimoutCounter;
static Boolean			gVideoModeTimedOut;


float		gGammaFadePercent;

int				gGameWindowWidth, gGameWindowHeight;


/****************  INIT WINDOW STUFF *******************/

void InitWindowStuff(void)
{
Rect			r;
GDHandle 		phGD;
DisplayIDType displayID;
float		scale,w,h;
long		totalVRAM;
OSErr		iErr;

#if 0
	if (gOSX)	//---------- for now, since DP4 doenst have DSp
	{
			/* CREATE A WINDOW TO PLAY IN */

		gCoverWindow = GetNewCWindow(128, nil, MOVE_TO_FRONT);
		ShowWindow(gCoverWindow);
		SetPort(GetWindowPort(gCoverWindow));
		ForeColor(whiteColor);
		BackColor(blackColor);

		GetPortBounds(GetWindowPort(gCoverWindow),&r);
		gGameWindowWidth = r.right - r.left;
		gGameWindowHeight = r.bottom - r.top;

	}
				/****************************/
				/* INIT WITH DRAW SPROCKETS */
				/****************************/
	else
#endif
	{
		PrepDrawSprockets();


					/* CLEAR SCREEN & MAKE WINDOW */

		w = gGamePrefs.screenWidth;
		h = gGamePrefs.screenHeight;

		DSpContext_GetDisplayID(gDisplayContext, &displayID);				// get context display ID
		iErr = DMGetGDeviceByDisplayID(displayID, &phGD, true);				// get GDHandle for ID'd device
		if (iErr != noErr)
		{
			DoFatalAlert("\pInitWindowStuff: DMGetGDeviceByDisplayID failed!");
		}

		r.top  		= (short) ((**phGD).gdRect.top + ((**phGD).gdRect.bottom - (**phGD).gdRect.top) / 2);	  	// h center
		r.top  		-= (short) (h / 2);
		r.left  	= (short) ((**phGD).gdRect.left + ((**phGD).gdRect.right - (**phGD).gdRect.left) / 2);		// v center
		r.left  	-= (short) (w / 2);
		r.right 	= (short) (r.left + w);
		r.bottom 	= (short) (r.top + h);

		scale = gGamePrefs.screenCrop * (w/2-10);
		r.left += scale;
		r.right -= scale;
		scale *= h/w;
		r.top += scale;
		r.bottom -= scale;

			/* FIRST CREATE A DUMMY WINDOW TO COVER ENTIRE DISPLAY */
			//
			// This is so when the real cover window is moved or sized, the background will erase to this desired color.
			//

		gCoverWindow = GetNewCWindow(128, nil, MOVE_TO_FRONT);
		MoveWindow(gCoverWindow, (**phGD).gdRect.left, (**phGD).gdRect.top, true);
		SizeWindow(gCoverWindow, (**phGD).gdRect.right - (**phGD).gdRect.left, (**phGD).gdRect.bottom - (**phGD).gdRect.top, false);
		ShowWindow(gCoverWindow);

				/* NOW CREATE THE REAL COVER WINDOW */

		gGameWindowWidth = r.right - r.left;
		gGameWindowHeight = r.bottom - r.top;

		gCoverWindow = GetNewCWindow(128, nil, MOVE_TO_FRONT);
		MoveWindow(gCoverWindow, r.left, r.top, true);
		SizeWindow(gCoverWindow, gGameWindowWidth, gGameWindowHeight, false);
		ShowWindow(gCoverWindow);

		SetPort(GetWindowPort(gCoverWindow));
		ForeColor(whiteColor);
		BackColor(blackColor);


				/************************************/
				/* GET SOME INFO ABOUT THIS GDEVICE */
				/************************************/

		if (OGL_CheckRenderer(phGD, &totalVRAM) == false)
			DoAlert("\pNo 3D hardware acceleration was found.  Check that the drivers for your 3D accelerator are installed properly");
		else
		{
#if 0 // this fucked up on AGP Systems like the iBook

				/* CHECK FOR INSUFFICIENT VRAM */

			if (totalVRAM <= (1024*1024*5))
			{
				DoAlert("\pThis application requires at least 6MB of VRAM to function properly.  The game will function limitedly with 4MB, so please install additional VRAM.");
			}
			else
#endif

				/* CHECK FOR LOW VRAM */

			{
				if (totalVRAM <= (1024*1024*6))
				{
					if (gGamePrefs.screenCrop < .3)			// crop the screen to give more VRAM
					{
						gGamePrefs.screenCrop = .3;
						ChangeWindowScale();
					}
				}
			}
		}
	}
}


/************************** CHANGE WINDOW SCALE ***********************/
//
// Called whenever gGameWindowShrink is changed.  This updates
// the view and everything else to accomodate new window size.
//

void ChangeWindowScale(void)
{
Rect			r;
GDHandle 		phGD;
DisplayIDType displayID;
float		scale,w,h;


	if (!gLoadedDrawSprocket)
		return;

	w = gGamePrefs.screenWidth;
	h = gGamePrefs.screenHeight;

			/* CALC NEW INFO */

	DSpContext_GetDisplayID(gDisplayContext, &displayID);			// get context display ID
	DMGetGDeviceByDisplayID(displayID, &phGD, false);				// get GDHandle for ID'd device

	r.top  		= (short) ((**phGD).gdRect.top + ((**phGD).gdRect.bottom - (**phGD).gdRect.top) / 2);	  	// h center
	r.top  		-= (short) (h / 2);
	r.left  	= (short) ((**phGD).gdRect.left + ((**phGD).gdRect.right - (**phGD).gdRect.left) / 2);		// v center
	r.left  	-= (short) (w / 2);
	r.right 	= (short) (r.left + w);
	r.bottom 	= (short) (r.top + h);

	scale 	= gGamePrefs.screenCrop * (float)(w/2-10);
	r.left 	+= scale;
	r.right -= scale;
	scale 	*= h/w;
	r.top 	+= scale;
	r.bottom -= scale;

	gGameWindowWidth = r.right - r.left;
	gGameWindowHeight = r.bottom - r.top;


			/* MODIFY THE WINODW TO THE NEW PARMS */

	HideWindow(gCoverWindow);
	MoveWindow(gCoverWindow, r.left, r.top, true);
	SizeWindow(gCoverWindow, gGameWindowWidth, gGameWindowHeight, false);
	ShowWindow(gCoverWindow);
}



/*==============================================================================
* Dobold ()
* this is the user item procedure to make the thick outline around the default
* button (assumed to be item 1)
*=============================================================================*/

pascal void DoBold (DialogPtr dlogPtr, short item)
{
short		itype;
Handle		ihandle;
Rect		irect;

	item;

	GetDialogItem (dlogPtr, 1, &itype, (Handle *)&ihandle, &irect);	/* get the buttons rect */
	PenSize (3, 3);											/* make thick lines	*/
	InsetRect (&irect, -4, -4);							/* grow rect a little   */
	FrameRoundRect (&irect, 16, 16);						/* frame the button now */
	PenNormal ();
}

/*==============================================================================
* DoOutline ()
* this is the user item procedure to make the thin outline around the given useritem
*=============================================================================*/

pascal void DoOutline (DialogPtr dlogPtr, short item)
{
short		itype;
Handle		ihandle;
Rect		irect;

	GetDialogItem (dlogPtr, item, &itype, (Handle *)&ihandle, &irect);	// get the user item's rect
	FrameRect (&irect);						// frame the button now
	PenNormal();
}


#pragma mark -

/****************** PREP DRAW SPROCKETS *********************/

static void PrepDrawSprockets(void)
{
DSpContextAttributes 	displayConfig;
OSStatus 				theError;
Boolean					confirmIt = false;
const RGBColor			rgbBlack	= { 0x0000, 0x0000, 0x0000 };

		/* startup DrawSprocket */

	theError = DSpStartup();
	if( theError )
	{
		DoFatalAlert("\pDSpStartup failed!");
	}
	gLoadedDrawSprocket = true;


				/*************************/
				/* SETUP A REQUEST BLOCK */
				/*************************/

try_again:

	displayConfig.frequency					= 00;
	displayConfig.displayWidth				= gGamePrefs.screenWidth;
	displayConfig.displayHeight				= gGamePrefs.screenHeight;
	displayConfig.reserved1					= 0;
	displayConfig.reserved2					= 0;
	displayConfig.colorNeeds				= kDSpColorNeeds_Request;
	displayConfig.colorTable				= NULL;
	displayConfig.contextOptions			= 0; //kDSpContextOption_QD3DAccel;
	displayConfig.backBufferDepthMask		= kDSpDepthMask_1;

	if (gGamePrefs.depth == 32)
		displayConfig.displayDepthMask			= kDSpDepthMask_32;
	else
		displayConfig.displayDepthMask			= kDSpDepthMask_16;

	displayConfig.backBufferBestDepth		= 1;
	displayConfig.displayBestDepth			= gGamePrefs.depth;
	displayConfig.pageCount					= 1;
	displayConfig.filler[0]                 = 0;
	displayConfig.filler[1]                 = 0;
	displayConfig.filler[2]                 = 0;
	displayConfig.gameMustConfirmSwitch		= false;
	displayConfig.reserved3[0]				= 0;
	displayConfig.reserved3[1]				= 0;
	displayConfig.reserved3[2]				= 0;
	displayConfig.reserved3[3]				= 0;



			/* FIND A MATCH */

	theError = DSpFindBestContext( &displayConfig, &gDisplayContext );
	if (theError)
	{
		gGamePrefs.showScreenModeDialog = true;		// show the settings dialog next time
		SavePrefs();

		if (gGamePrefs.screenWidth >= 1024)		// if we could not find it and it was 1024 then probably on an iBook, so try 640x480 mode.
		{
			gGamePrefs.screenWidth  = 640;
			gGamePrefs.screenHeight = 480;
			gGamePrefs.depth = 16;
			goto try_again;
		}
		else
		{
			DoAlert("\pPrepDrawSprockets: DSpFindBestContext failed");
			DoFatalAlert("\pDraw Sprocket could not set monitor to desired resolution and/or depth");
		}
	}

				/* RESERVE IT */

	theError = DSpContext_Reserve( gDisplayContext, &displayConfig );
	if( theError )
		DoFatalAlert("\pPrepDrawSprockets: DSpContext_Reserve failed");

	DSpSetBlankingColor(&rgbBlack);


			/* MAKE STATE ACTIVE */

	theError = DSpContext_SetState( gDisplayContext, kDSpContextState_Active );
	if (theError == kDSpConfirmSwitchWarning)
	{
		confirmIt = true;
	}
	else
	if (theError)
	{
		DSpContext_Release( gDisplayContext );
		gDisplayContext = nil;
		DoFatalAlert("\pPrepDrawSprockets: DSpContext_SetState failed");
		return;
	}

#if ALLOW_FADE
	DSpContext_FadeGamma(MONITORS_TO_FADE,100,nil);
#else

	DSpContext_FadeGamma(gDisplayContext,100,nil);
#endif
}


/**************** DO VIDEO CONFIRM DIALOG *********************/

static void DoVideoConfirmDialog(void)
{
DialogPtr			myDialog;
ModalFilterUPP	myProc;
Boolean				dialogDone;
short				itemHit;

#if ALLOW_FADE
	DSpContext_FadeGamma(MONITORS_TO_FADE,100,nil);						// make sure we can see it
#endif

//	DSpContext_GetBackBuffer(gDisplayContext,kDSpBufferKind_Normal,(CGrafPtr *)&gCoverWindow);
//	SetPort(gCoverWindow);
//	gCoverWindow = nil;

	myDialog = GetNewDialog(128,nil,MOVE_TO_FRONT);

	dialogDone = false;
	gVideoModeTimedOut = false;

	myProc = NewModalFilterProc(VideoModeTimeOut);
	gVideoModeTimoutCounter = TickCount();					// get start time for timeout clock


	while(!dialogDone)
	{
		InitCursor();
		ModalDialog(myProc, &itemHit);
		switch (itemHit)
		{
			case	2:
					dialogDone = true;
					break;
		}

		if (gVideoModeTimedOut)								// see if timed out
			break;
	}

	DisposeModalFilterUPP(myProc);
	DisposeDialog(myDialog);
	HideCursor();
}

/****************** VIDEO MODE TIMOUT *************************/
//
// Callback routine from above
//

static pascal Boolean VideoModeTimeOut (DialogPtr dp,EventRecord *event, short *item)
{
Boolean handled = false;
long			tick;
static long		oldTick = -1;
short			itemType;
Handle			itemHandle;
Rect			itemRect;
Str255			s;

	event; item;

			/* HANDLE DIALOG EVENTS */
#if 0
	switch (event->what)
	{
		case keyDown:
			switch (event->message & charCodeMask)
			{
				case 	0x03:  					// Enter
				case 	0x0D: 					// Return
						*item = 1;
						handled = true;
						break;
			}
	}
#endif
				/* CHECK TIMEOUT */

	tick = 	TickCount() - gVideoModeTimoutCounter;
	tick /= 60;
	tick = 5-tick;

	if (tick <= 0)
	{
		gVideoModeTimedOut = true;
		handled = true;
		SysBeep(0);
	}

			/* UPDATE TIMER VALUE */

	if (tick < 0)
		tick = 0;
	if (tick != oldTick)
	{
		NumToString(tick,s);
		GetDialogItem(dp,1,&itemType,(Handle *)&itemHandle,&itemRect);
		SetDialogItemText((Handle)itemHandle,s);
		oldTick = tick;
	}

	return(handled);
}

/**************** GAMMA FADE IN *************************/

void GammaFadeIn(void)
{
#if ALLOW_FADE
	if (gDisplayContext)
	{
		while(gGammaFadePercent < 100)
		{
			gGammaFadePercent += 7;
			if (gGammaFadePercent > 100)
				gGammaFadePercent = 100;

			DSpContext_FadeGamma(gDisplayContext,gGammaFadePercent,nil);

			Wait(1);

					/* KEEP MUSIC PLAYING */

			if (gSongPlayingFlag)
				MoviesTask(gSongMovie, 0);
		}
	}
#endif
}

/**************** GAMMA FADE OUT *************************/

void GammaFadeOut(void)
{
#if ALLOW_FADE
	if (gDisplayContext)
	{
		while(gGammaFadePercent > 0)
		{
			gGammaFadePercent -= 7;
			if (gGammaFadePercent < 0)
				gGammaFadePercent = 0;

			DSpContext_FadeGamma(gDisplayContext,gGammaFadePercent,nil);

			Wait(1);

					/* KEEP MUSIC PLAYING */

			if (gSongPlayingFlag)
				MoviesTask(gSongMovie, 0);
		}
	}
#endif

	if (g1PixelWindow)
	{
		DisposeWindow(g1PixelWindow);
		g1PixelWindow = nil;
	}

}

/********************** GAMMA ON *********************/

void GammaOn(void)
{
#if ALLOW_FADE

	if (gDisplayContext)
	{
		if (gGammaFadePercent != 100)
		{
			DSpContext_FadeGamma(MONITORS_TO_FADE,100,nil);
			gGammaFadePercent = 100;
		}
	}
#endif
}


/***************** SETUP EVENT PROC ******************/

static Boolean SetupEventProc(EventRecord *event)
{
	event;
	return(false);
}


/****************** CLEANUP DISPLAY *************************/

void CleanupDisplay(void)
{
OSStatus 		theError;

	if(gDisplayContext != nil)
	{
#if ALLOW_FADE
		DSpContext_FadeGammaOut(gDisplayContext,nil);						// fade out	ours
#endif


		DSpContext_SetState( gDisplayContext, kDSpContextState_Inactive );	// deactivate


#if ALLOW_FADE
		DSpContext_FadeGamma(MONITORS_TO_FADE,100,nil);						// gamme on all
#endif
		DSpContext_Release( gDisplayContext );								// release

		gDisplayContext = nil;
	}


	/* shutdown draw sprocket */

	if (gLoadedDrawSprocket)
	{
		theError = DSpShutdown();
		gLoadedDrawSprocket = false;
	}
}


/******************** MAKE FADE EVENT *********************/
//
// INPUT:	fadeIn = true if want fade IN, otherwise fade OUT.
//

void MakeFadeEvent(Boolean	fadeIn)
{
#if ALLOW_FADE
ObjNode	*newObj;
ObjNode		*thisNodePtr;

		/* SCAN FOR OLD FADE EVENTS STILL IN LIST */

	thisNodePtr = gFirstNodePtr;

	while (thisNodePtr)
	{
		if ((thisNodePtr->Slot == SLOT_OF_DUMB) &&
			(thisNodePtr->MoveCall == MoveFadeEvent))
		{
			thisNodePtr->Flag[0] = fadeIn;								// set new mode
			return;
		}
		thisNodePtr = thisNodePtr->NextNode;							// next node
	}


		/* MAKE NEW FADE EVENT */

	gNewObjectDefinition.genre = EVENT_GENRE;
	gNewObjectDefinition.coord.x = 0;
	gNewObjectDefinition.coord.y = 0;
	gNewObjectDefinition.coord.z = 0;
	gNewObjectDefinition.flags = 0;
	gNewObjectDefinition.slot = SLOT_OF_DUMB;
	gNewObjectDefinition.moveCall = MoveFadeEvent;
	newObj = MakeNewObject(&gNewObjectDefinition);
	if (newObj == nil)
		return;

	newObj->Flag[0] = fadeIn;
#endif
}


/***************** MOVE FADE EVENT ********************/

static void MoveFadeEvent(ObjNode *theNode)
{
float	fps = gFramesPerSecondFrac;

			/* SEE IF FADE IN */

	if (theNode->Flag[0])
	{
		if (gGammaFadePercent >= 100.0f)										// see if @ 100%
		{
			gGammaFadePercent = 100;
			DeleteObject(theNode);
		}
#if ALLOW_FADE
		if (gDisplayContext)
			DSpContext_FadeGamma(gDisplayContext,gGammaFadePercent,nil);
#endif
		gGammaFadePercent += 400.0f*fps;
		if (gGammaFadePercent >= 100.0f)										// see if @ 100%
			gGammaFadePercent = 100;
	}

			/* FADE OUT */
	else
	{
		if (gGammaFadePercent <= 0.0f)													// see if @ 0%
		{
			gGammaFadePercent = 0;
			DeleteObject(theNode);
		}
#if ALLOW_FADE
		if (gDisplayContext)
			DSpContext_FadeGamma(gDisplayContext,gGammaFadePercent,nil);
#endif
		gGammaFadePercent -= 400.0f*fps;
		if (gGammaFadePercent <= 0.0f)													// see if @ 0%
			gGammaFadePercent = 0;
	}
}


/************************ GAME SCREEN TO BLACK ************************/

void GameScreenToBlack(void)
{
	if (gCoverWindow)
	{
		Rect	r;

		SetPort(GetWindowPort(gCoverWindow));
		BackColor(blackColor);

		GetPortBounds(GetWindowPort(gCoverWindow), &r);
		EraseRect(&r);
	}
}



#pragma mark -

/*********************** DUMP GWORLD 2 **********************/
//
//    copies to a destination RECT
//

void DumpGWorld2(GWorldPtr thisWorld, WindowPtr thisWindow,Rect *destRect)
{
PixMapHandle pm;
GDHandle		oldGD;
GWorldPtr		oldGW;
Rect			r;

	DoLockPixels(thisWorld);

	GetGWorld (&oldGW,&oldGD);
	pm = GetGWorldPixMap(thisWorld);
	if ((pm == nil) | (*pm == nil) )
		DoAlert("\pPixMap Handle or Ptr = Null?!");

	SetPort(GetWindowPort(thisWindow));

	ForeColor(blackColor);
	BackColor(whiteColor);

	GetPortBounds(thisWorld, &r);

	CopyBits((BitMap *)*pm, GetPortBitMapForCopyBits(GetWindowPort(thisWindow)),
			 &r,
			 destRect,
			 srcCopy, 0);

	SetGWorld(oldGW,oldGD);								// restore gworld
}


/******************* DO LOCK PIXELS **************/

void DoLockPixels(GWorldPtr world)
{
PixMapHandle pm;

	pm = GetGWorldPixMap(world);
	if (LockPixels(pm) == false)
		DoFatalAlert("\pPixMap Went Bye,Bye?!");
}


/********************** WAIT **********************/

void Wait(long ticks)
{
long	start;

	start = TickCount();

	while (TickCount()-start < ticks);

}





